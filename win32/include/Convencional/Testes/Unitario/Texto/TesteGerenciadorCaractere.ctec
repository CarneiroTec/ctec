#Inclua "../../../Fonte/Texto/GerenciadorCaractere.ctec"
#Inclua <assert.h>
#Inclua <ctype.h>
#Inclua <wctype.h>
#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <time.h>

// **Valida: Requisitos 1.2, 3.1, 4.1**
// **Propriedade 12: Equivalência Comportamental**
// Testa se as funções de caractere encapsuladas produzem os mesmos resultados que as originais

// Gerador de dados aleatórios para testes de propriedade
Inteiro gere_caractere_ascii_aleatorio() {
    // Gerar caracteres ASCII (0-127)
    Retorne rand() % 128;
}

Inteiro gere_caractere_imprimivel_aleatorio() {
    // Gerar caracteres ASCII imprimíveis (32-126)
    Retorne 32 + (rand() % 95);
}

CaractereUnicode gere_caractere_unicode_aleatorio() {
    // Gerar caracteres Unicode básicos (0-255)
    Retorne rand() % 256;
}

// Teste de propriedade: Classificação de letras deve ter comportamento equivalente
Inteiro teste_equivalencia_é_letra() {
    printf("Testando equivalência de é_letra...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_letra(caractere);
        Inteiro resultado_original = isalpha(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Classificação de dígitos deve ter comportamento equivalente
Inteiro teste_equivalencia_é_dígito() {
    printf("Testando equivalência de é_dígito...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_dígito(caractere);
        Inteiro resultado_original = isdigit(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Conversão para maiúscula deve ter comportamento equivalente
Inteiro teste_equivalencia_para_maiúscula() {
    printf("Testando equivalência de para_maiúscula...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.para_maiúscula(caractere);
        Inteiro resultado_original = toupper(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert(resultado_gerenciador == resultado_original);
    }
    
    Retorne 1;
}

// Teste de propriedade: Conversão para minúscula deve ter comportamento equivalente
Inteiro teste_equivalencia_para_minúscula() {
    printf("Testando equivalência de para_minúscula...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.para_minúscula(caractere);
        Inteiro resultado_original = tolower(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert(resultado_gerenciador == resultado_original);
    }
    
    Retorne 1;
}

// Teste de propriedade: Classificação alfanumérica deve ter comportamento equivalente
Inteiro teste_equivalencia_é_alfanumérico() {
    printf("Testando equivalência de é_alfanumérico...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_alfanumérico(caractere);
        Inteiro resultado_original = isalnum(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Classificação de espaço deve ter comportamento equivalente
Inteiro teste_equivalencia_é_espaço() {
    printf("Testando equivalência de é_espaço...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_espaço(caractere);
        Inteiro resultado_original = isspace(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Classificação de pontuação deve ter comportamento equivalente
Inteiro teste_equivalencia_é_pontuação() {
    printf("Testando equivalência de é_pontuação...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_pontuação(caractere);
        Inteiro resultado_original = ispunct(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Classificação de controle deve ter comportamento equivalente
Inteiro teste_equivalencia_é_controle() {
    printf("Testando equivalência de é_controle...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_controle(caractere);
        Inteiro resultado_original = iscntrl(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Classificação de imprimível deve ter comportamento equivalente
Inteiro teste_equivalencia_é_imprimível() {
    printf("Testando equivalência de é_imprimível...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_imprimível(caractere);
        Inteiro resultado_original = isprint(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Classificação de gráfico deve ter comportamento equivalente
Inteiro teste_equivalencia_é_gráfico() {
    printf("Testando equivalência de é_gráfico...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_gráfico(caractere);
        Inteiro resultado_original = isgraph(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Classificação de maiúscula deve ter comportamento equivalente
Inteiro teste_equivalencia_é_maiúscula() {
    printf("Testando equivalência de é_maiúscula...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_maiúscula(caractere);
        Inteiro resultado_original = isupper(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Classificação de minúscula deve ter comportamento equivalente
Inteiro teste_equivalencia_é_minúscula() {
    printf("Testando equivalência de é_minúscula...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_minúscula(caractere);
        Inteiro resultado_original = islower(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Classificação de hexadecimal deve ter comportamento equivalente
Inteiro teste_equivalencia_é_hexadecimal() {
    printf("Testando equivalência de é_hexadecimal...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        Inteiro caractere = gere_caractere_ascii_aleatorio();
        
        // Comparar com função original
        Inteiro resultado_gerenciador = GerenciadorCaractere.é_hexadecimal(caractere);
        Inteiro resultado_original = isxdigit(caractere);
        
        // Ambos devem retornar o mesmo resultado
        assert((resultado_gerenciador != 0) == (resultado_original != 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Operações Unicode devem ter comportamento equivalente
Inteiro teste_equivalencia_unicode() {
    printf("Testando equivalência de operações Unicode...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        CaractereUnicode caractere = gere_caractere_unicode_aleatorio();
        
        // Teste é_letra_unicode
        Inteiro resultado_letra_gerenciador = GerenciadorCaractere.é_letra_unicode(caractere);
        Inteiro resultado_letra_original = iswalpha(caractere);
        assert((resultado_letra_gerenciador != 0) == (resultado_letra_original != 0));
        
        // Teste é_dígito_unicode
        Inteiro resultado_digito_gerenciador = GerenciadorCaractere.é_dígito_unicode(caractere);
        Inteiro resultado_digito_original = iswdigit(caractere);
        assert((resultado_digito_gerenciador != 0) == (resultado_digito_original != 0));
        
        // Teste para_maiúscula_unicode
        CaractereUnicode resultado_maiuscula_gerenciador = GerenciadorCaractere.para_maiúscula_unicode(caractere);
        CaractereUnicode resultado_maiuscula_original = towupper(caractere);
        assert(resultado_maiuscula_gerenciador == resultado_maiuscula_original);
        
        // Teste para_minúscula_unicode
        CaractereUnicode resultado_minuscula_gerenciador = GerenciadorCaractere.para_minúscula_unicode(caractere);
        CaractereUnicode resultado_minuscula_original = towlower(caractere);
        assert(resultado_minuscula_gerenciador == resultado_minuscula_original);
    }
    
    Retorne 1;
}

// Teste específico para funcionalidades portuguesas
Inteiro teste_funcionalidades_português() {
    printf("Testando funcionalidades específicas para português...\n");
    
    // Teste de vogais
    assert(GerenciadorCaractere.é_vogal('a') == 1);
    assert(GerenciadorCaractere.é_vogal('e') == 1);
    assert(GerenciadorCaractere.é_vogal('i') == 1);
    assert(GerenciadorCaractere.é_vogal('o') == 1);
    assert(GerenciadorCaractere.é_vogal('u') == 1);
    assert(GerenciadorCaractere.é_vogal('A') == 1);
    assert(GerenciadorCaractere.é_vogal('E') == 1);
    assert(GerenciadorCaractere.é_vogal('I') == 1);
    assert(GerenciadorCaractere.é_vogal('O') == 1);
    assert(GerenciadorCaractere.é_vogal('U') == 1);
    
    // Teste de consoantes
    assert(GerenciadorCaractere.é_consoante('b') == 1);
    assert(GerenciadorCaractere.é_consoante('c') == 1);
    assert(GerenciadorCaractere.é_consoante('d') == 1);
    assert(GerenciadorCaractere.é_consoante('B') == 1);
    assert(GerenciadorCaractere.é_consoante('C') == 1);
    assert(GerenciadorCaractere.é_consoante('D') == 1);
    
    // Teste de não-letras
    assert(GerenciadorCaractere.é_vogal('1') == 0);
    assert(GerenciadorCaractere.é_consoante('1') == 0);
    assert(GerenciadorCaractere.é_vogal(' ') == 0);
    assert(GerenciadorCaractere.é_consoante(' ') == 0);
    
    // Teste de cedilha
    assert(GerenciadorCaractere.é_cedilha('ç') == 1);
    assert(GerenciadorCaractere.é_cedilha('Ç') == 1);
    assert(GerenciadorCaractere.é_cedilha('c') == 0);
    assert(GerenciadorCaractere.é_cedilha('C') == 0);
    
    // Teste de remoção de acentos
    assert(GerenciadorCaractere.remova_acento('á') == 'a');
    assert(GerenciadorCaractere.remova_acento('é') == 'e');
    assert(GerenciadorCaractere.remova_acento('í') == 'i');
    assert(GerenciadorCaractere.remova_acento('ó') == 'o');
    assert(GerenciadorCaractere.remova_acento('ú') == 'u');
    assert(GerenciadorCaractere.remova_acento('Á') == 'A');
    assert(GerenciadorCaractere.remova_acento('É') == 'E');
    assert(GerenciadorCaractere.remova_acento('Í') == 'I');
    assert(GerenciadorCaractere.remova_acento('Ó') == 'O');
    assert(GerenciadorCaractere.remova_acento('Ú') == 'U');
    assert(GerenciadorCaractere.remova_acento('ç') == 'c');
    assert(GerenciadorCaractere.remova_acento('Ç') == 'C');
    
    // Teste de caracteres sem acento (devem permanecer iguais)
    assert(GerenciadorCaractere.remova_acento('a') == 'a');
    assert(GerenciadorCaractere.remova_acento('A') == 'A');
    assert(GerenciadorCaractere.remova_acento('1') == '1');
    assert(GerenciadorCaractere.remova_acento(' ') == ' ');
    
    Retorne 1;
}

// Teste de valores numéricos
Inteiro teste_valores_numéricos() {
    printf("Testando obtenção de valores numéricos...\n");
    
    // Teste de dígitos decimais
    assert(GerenciadorCaractere.obtenha_valor_numérico('0') == 0);
    assert(GerenciadorCaractere.obtenha_valor_numérico('1') == 1);
    assert(GerenciadorCaractere.obtenha_valor_numérico('5') == 5);
    assert(GerenciadorCaractere.obtenha_valor_numérico('9') == 9);
    
    // Teste de dígitos hexadecimais
    assert(GerenciadorCaractere.obtenha_valor_numérico('A') == 10);
    assert(GerenciadorCaractere.obtenha_valor_numérico('F') == 15);
    assert(GerenciadorCaractere.obtenha_valor_numérico('a') == 10);
    assert(GerenciadorCaractere.obtenha_valor_numérico('f') == 15);
    
    // Teste de caracteres inválidos
    assert(GerenciadorCaractere.obtenha_valor_numérico('G') == -1);
    assert(GerenciadorCaractere.obtenha_valor_numérico('z') == -1);
    assert(GerenciadorCaractere.obtenha_valor_numérico(' ') == -1);
    assert(GerenciadorCaractere.obtenha_valor_numérico('@') == -1);
    
    Retorne 1;
}

// Teste de classificação de caracteres
Inteiro teste_classificação_caracteres() {
    printf("Testando classificação de caracteres...\n");
    
    // Teste de letras
    TipoCaractere tipo_a = GerenciadorCaractere.classifique_caractere('a');
    assert(tipo_a == TIPO_MINUSCULA);
    
    TipoCaractere tipo_A = GerenciadorCaractere.classifique_caractere('A');
    assert(tipo_A == TIPO_MAIUSCULA);
    
    // Teste de dígitos
    TipoCaractere tipo_5 = GerenciadorCaractere.classifique_caractere('5');
    assert(tipo_5 == TIPO_DIGITO);
    
    // Teste de espaços
    TipoCaractere tipo_espaco = GerenciadorCaractere.classifique_caractere(' ');
    assert(tipo_espaco == TIPO_ESPACO);
    
    // Teste de pontuação
    TipoCaractere tipo_ponto = GerenciadorCaractere.classifique_caractere('.');
    assert(tipo_ponto == TIPO_PONTUACAO);
    
    Retorne 1;
}

// Teste de validação de codificações
Inteiro teste_validação_codificações() {
    printf("Testando validação de codificações...\n");
    
    // Teste ASCII válido
    assert(GerenciadorCaractere.é_válido_ascii('A') == 1);
    assert(GerenciadorCaractere.é_válido_ascii('0') == 1);
    assert(GerenciadorCaractere.é_válido_ascii(' ') == 1);
    assert(GerenciadorCaractere.é_válido_ascii(127) == 1);
    
    // Teste ASCII inválido
    assert(GerenciadorCaractere.é_válido_ascii(128) == 0);
    assert(GerenciadorCaractere.é_válido_ascii(255) == 0);
    assert(GerenciadorCaractere.é_válido_ascii(-1) == 0);
    
    // Teste Latin-1 válido
    assert(GerenciadorCaractere.é_válido_latin1('A') == 1);
    assert(GerenciadorCaractere.é_válido_latin1(128) == 1);
    assert(GerenciadorCaractere.é_válido_latin1(255) == 1);
    
    // Teste Latin-1 inválido
    assert(GerenciadorCaractere.é_válido_latin1(256) == 0);
    assert(GerenciadorCaractere.é_válido_latin1(-1) == 0);
    
    Retorne 1;
}

// Teste de funcionalidades Unicode específicas para português
Inteiro teste_unicode_português() {
    printf("Testando funcionalidades Unicode para português...\n");
    
    // Teste de vogais Unicode
    assert(GerenciadorCaractere.é_vogal_unicode(L'a') == 1);
    assert(GerenciadorCaractere.é_vogal_unicode(L'á') == 1);
    assert(GerenciadorCaractere.é_vogal_unicode(L'à') == 1);
    assert(GerenciadorCaractere.é_vogal_unicode(L'ã') == 1);
    assert(GerenciadorCaractere.é_vogal_unicode(L'â') == 1);
    
    // Teste de consoantes Unicode
    assert(GerenciadorCaractere.é_consoante_unicode(L'b') == 1);
    assert(GerenciadorCaractere.é_consoante_unicode(L'ç') == 1);
    
    // Teste de remoção de acentos Unicode
    assert(GerenciadorCaractere.remova_acento_unicode(L'á') == L'a');
    assert(GerenciadorCaractere.remova_acento_unicode(L'é') == L'e');
    assert(GerenciadorCaractere.remova_acento_unicode(L'ç') == L'c');
    assert(GerenciadorCaractere.remova_acento_unicode(L'Ç') == L'C');
    
    // Teste de caracteres sem acento (devem permanecer iguais)
    assert(GerenciadorCaractere.remova_acento_unicode(L'a') == L'a');
    assert(GerenciadorCaractere.remova_acento_unicode(L'A') == L'A');
    
    Retorne 1;
}

Inteiro executar_todos_testes() {
    printf("Executando testes de propriedade para GerenciadorCaractere...\n");
    printf("**Valida: Requisitos 1.2, 3.1, 4.1**\n");
    printf("**Propriedade 12: Equivalência Comportamental**\n\n");
    
    // Inicializar gerador de números aleatórios
    srand((Inteiro)time(NULL));
    
    // Testes de equivalência comportamental
    assert(teste_equivalencia_é_letra());
    printf("✓ Teste equivalência é_letra passou\n");
    
    assert(teste_equivalencia_é_dígito());
    printf("✓ Teste equivalência é_dígito passou\n");
    
    assert(teste_equivalencia_para_maiúscula());
    printf("✓ Teste equivalência para_maiúscula passou\n");
    
    assert(teste_equivalencia_para_minúscula());
    printf("✓ Teste equivalência para_minúscula passou\n");
    
    assert(teste_equivalencia_é_alfanumérico());
    printf("✓ Teste equivalência é_alfanumérico passou\n");
    
    assert(teste_equivalencia_é_espaço());
    printf("✓ Teste equivalência é_espaço passou\n");
    
    assert(teste_equivalencia_é_pontuação());
    printf("✓ Teste equivalência é_pontuação passou\n");
    
    assert(teste_equivalencia_é_controle());
    printf("✓ Teste equivalência é_controle passou\n");
    
    assert(teste_equivalencia_é_imprimível());
    printf("✓ Teste equivalência é_imprimível passou\n");
    
    assert(teste_equivalencia_é_gráfico());
    printf("✓ Teste equivalência é_gráfico passou\n");
    
    assert(teste_equivalencia_é_maiúscula());
    printf("✓ Teste equivalência é_maiúscula passou\n");
    
    assert(teste_equivalencia_é_minúscula());
    printf("✓ Teste equivalência é_minúscula passou\n");
    
    assert(teste_equivalencia_é_hexadecimal());
    printf("✓ Teste equivalência é_hexadecimal passou\n");
    
    assert(teste_equivalencia_unicode());
    printf("✓ Teste equivalência operações Unicode passou\n");
    
    // Testes específicos para funcionalidades portuguesas
    assert(teste_funcionalidades_português());
    printf("✓ Teste funcionalidades específicas para português passou\n");
    
    assert(teste_valores_numéricos());
    printf("✓ Teste obtenção de valores numéricos passou\n");
    
    assert(teste_classificação_caracteres());
    printf("✓ Teste classificação de caracteres passou\n");
    
    assert(teste_validação_codificações());
    printf("✓ Teste validação de codificações passou\n");
    
    assert(teste_unicode_português());
    printf("✓ Teste funcionalidades Unicode para português passou\n");
    
    printf("\nTodos os testes para GerenciadorCaractere passaram com sucesso!\n");
    printf("Propriedade 12 (Equivalência Comportamental) validada com 100 iterações por teste.\n");
    printf("Funcionalidades específicas para português validadas.\n");
    printf("Encapsulamento de ctype.h e wctype.h completo e funcional.\n");
    
    Retorne 1;
}

Inteiro Início() {
    Retorne executar_todos_testes() ? 0 : 1;
}