#Inclua "../../../Fonte/Texto/GerenciadorTexto.ctec"
#Inclua <assert.h>
#Inclua <string.h>
#Inclua <wchar.h>
#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <time.h>

// **Valida: Requisitos 7.2**
// **Propriedade 12: Equivalência Comportamental**
// Testa se as funções de texto encapsuladas produzem os mesmos resultados que as originais

// Gerador de dados aleatórios para testes de propriedade
Inteiro gere_tamanho_aleatorio(Inteiro min, Inteiro max) {
    Retorne min + (rand() % (max - min + 1));
}

Caractere gere_caractere_aleatorio() {
    // Gerar caracteres ASCII imprimíveis (32-126)
    Retorne 32 + (rand() % 95);
}

Vazio gere_string_aleatoria(Caractere *buffer, TamanhoTexto tamanho) {
    Para (TamanhoTexto i = 0; i < tamanho - 1; i++) {
        buffer[i] = gere_caractere_aleatorio();
    }
    buffer[tamanho - 1] = '\0';
}

// Teste de propriedade: Obtenção de tamanho deve ter comportamento equivalente
Inteiro teste_equivalencia_obtenha_tamanho() {
    printf("Testando equivalência de obtenção de tamanho...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoTexto tamanho = gere_tamanho_aleatorio(0, 500);
        Caractere *texto = (Caractere*)malloc(tamanho + 1);
        assert(texto);
        
        gere_string_aleatoria(texto, tamanho + 1);
        
        // Comparar com função original
        TamanhoTexto resultado_gerenciador = GerenciadorTexto.obtenha_tamanho(texto);
        size_t resultado_original = strlen(texto);
        
        // Ambos devem retornar o mesmo tamanho
        assert(resultado_gerenciador == resultado_original);
        
        free(texto);
    }
    
    Retorne 1;
}

// Teste de propriedade: Cópia de texto deve ter comportamento equivalente
Inteiro teste_equivalencia_copie_texto() {
    printf("Testando equivalência de cópia de texto...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoTexto tamanho = gere_tamanho_aleatorio(1, 200);
        Caractere *origem = (Caractere*)malloc(tamanho + 1);
        Caractere *destino_gerenciador = (Caractere*)malloc(tamanho + 1);
        Caractere *destino_original = (Caractere*)malloc(tamanho + 1);
        
        assert(origem && destino_gerenciador && destino_original);
        
        gere_string_aleatoria(origem, tamanho + 1);
        
        // Copiar usando ambas as implementações
        Caractere *resultado_gerenciador = GerenciadorTexto.copie_texto(destino_gerenciador, origem);
        Caractere *resultado_original = strcpy(destino_original, origem);
        
        // Ambos devem retornar o ponteiro de destino
        assert(resultado_gerenciador == destino_gerenciador);
        assert(resultado_original == destino_original);
        
        // O conteúdo copiado deve ser idêntico
        assert(strcmp(destino_gerenciador, destino_original) == 0);
        assert(strcmp(destino_gerenciador, origem) == 0);
        
        free(origem);
        free(destino_gerenciador);
        free(destino_original);
    }
    
    Retorne 1;
}

// Teste de propriedade: Concatenação de texto deve ter comportamento equivalente
Inteiro teste_equivalencia_concatene_texto() {
    printf("Testando equivalência de concatenação de texto...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoTexto tamanho1 = gere_tamanho_aleatorio(1, 100);
        TamanhoTexto tamanho2 = gere_tamanho_aleatorio(1, 100);
        
        Caractere *texto1 = (Caractere*)malloc(tamanho1 + 1);
        Caractere *texto2 = (Caractere*)malloc(tamanho2 + 1);
        Caractere *destino_gerenciador = (Caractere*)malloc(tamanho1 + tamanho2 + 2);
        Caractere *destino_original = (Caractere*)malloc(tamanho1 + tamanho2 + 2);
        
        assert(texto1 && texto2 && destino_gerenciador && destino_original);
        
        gere_string_aleatoria(texto1, tamanho1 + 1);
        gere_string_aleatoria(texto2, tamanho2 + 1);
        
        // Copiar texto inicial para ambos os destinos
        strcpy(destino_gerenciador, texto1);
        strcpy(destino_original, texto1);
        
        // Concatenar usando ambas as implementações
        Caractere *resultado_gerenciador = GerenciadorTexto.concatene_texto(destino_gerenciador, texto2);
        Caractere *resultado_original = strcat(destino_original, texto2);
        
        // Ambos devem retornar o ponteiro de destino
        assert(resultado_gerenciador == destino_gerenciador);
        assert(resultado_original == destino_original);
        
        // O resultado deve ser idêntico
        assert(strcmp(destino_gerenciador, destino_original) == 0);
        
        free(texto1);
        free(texto2);
        free(destino_gerenciador);
        free(destino_original);
    }
    
    Retorne 1;
}

// Teste de propriedade: Comparação de texto deve ter comportamento equivalente
Inteiro teste_equivalencia_compare_texto() {
    printf("Testando equivalência de comparação de texto...\n");
    
    Imutável Caractere *strings_teste[] = {
        "abc", "ABC", "123", "teste", "TESTE", "", "a", "aa", "ab", "ba"
    };
    Inteiro num_strings = 10;
    
    Para (Inteiro i = 0; i < num_strings; i++) {
        Para (Inteiro j = 0; j < num_strings; j++) {
            // Comparar usando ambas as implementações
            Inteiro resultado_gerenciador = GerenciadorTexto.compare_texto(strings_teste[i], strings_teste[j]);
            Inteiro resultado_original = strcmp(strings_teste[i], strings_teste[j]);
            
            // Ambos devem ter o mesmo sinal
            assert((resultado_gerenciador > 0) == (resultado_original > 0));
            assert((resultado_gerenciador < 0) == (resultado_original < 0));
            assert((resultado_gerenciador == 0) == (resultado_original == 0));
        }
    }
    
    Retorne 1;
}

// Teste de propriedade: Busca de caractere deve ter comportamento equivalente
Inteiro teste_equivalencia_busque_caractere() {
    printf("Testando equivalência de busca de caractere...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoTexto tamanho = gere_tamanho_aleatorio(10, 200);
        Caractere *texto = (Caractere*)malloc(tamanho + 1);
        assert(texto);
        
        gere_string_aleatoria(texto, tamanho + 1);
        
        // Escolher um caractere para buscar (50% das vezes um que existe)
        Caractere caractere_busca;
        Se (rand() % 2 && tamanho > 0) {
            // Buscar um caractere que existe no texto
            TamanhoTexto pos = gere_tamanho_aleatorio(0, strlen(texto) - 1);
            caractere_busca = texto[pos];
        } Senão {
            // Buscar um caractere aleatório
            caractere_busca = gere_caractere_aleatorio();
        }
        
        // Buscar usando ambas as implementações
        Caractere *resultado_gerenciador = GerenciadorTexto.busque_caractere(texto, caractere_busca);
        Caractere *resultado_original = strchr(texto, caractere_busca);
        
        // Ambos devem ter o mesmo resultado
        assert(resultado_gerenciador == resultado_original);
        
        // Se encontrado, deve apontar para o caractere correto
        Se (resultado_gerenciador) {
            assert(*resultado_gerenciador == caractere_busca);
            assert(*resultado_original == caractere_busca);
        }
        
        free(texto);
    }
    
    Retorne 1;
}

// Teste de propriedade: Busca de último caractere deve ter comportamento equivalente
Inteiro teste_equivalencia_busque_ultimo_caractere() {
    printf("Testando equivalência de busca de último caractere...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoTexto tamanho = gere_tamanho_aleatorio(10, 200);
        Caractere *texto = (Caractere*)malloc(tamanho + 1);
        assert(texto);
        
        gere_string_aleatoria(texto, tamanho + 1);
        
        // Escolher um caractere para buscar
        Caractere caractere_busca = gere_caractere_aleatorio();
        
        // Buscar usando ambas as implementações
        Caractere *resultado_gerenciador = GerenciadorTexto.busque_ultimo_caractere(texto, caractere_busca);
        Caractere *resultado_original = strrchr(texto, caractere_busca);
        
        // Ambos devem ter o mesmo resultado
        assert(resultado_gerenciador == resultado_original);
        
        // Se encontrado, deve apontar para o caractere correto
        Se (resultado_gerenciador) {
            assert(*resultado_gerenciador == caractere_busca);
            assert(*resultado_original == caractere_busca);
        }
        
        free(texto);
    }
    
    Retorne 1;
}

// Teste de propriedade: Busca de texto deve ter comportamento equivalente
Inteiro teste_equivalencia_busque_texto() {
    printf("Testando equivalência de busca de texto...\n");
    
    Imutável Caractere *textos_base[] = {
        "Hello World", "teste de busca", "abc123def", "MAIUSCULA", "minuscula"
    };
    Imutável Caractere *subtextos[] = {
        "World", "teste", "123", "MAIUS", "min", "xyz", ""
    };
    
    Inteiro num_textos = 5;
    Inteiro num_subtextos = 7;
    
    Para (Inteiro i = 0; i < num_textos; i++) {
        Para (Inteiro j = 0; j < num_subtextos; j++) {
            // Buscar usando ambas as implementações
            Caractere *resultado_gerenciador = GerenciadorTexto.busque_texto(textos_base[i], subtextos[j]);
            Caractere *resultado_original = strstr(textos_base[i], subtextos[j]);
            
            // Ambos devem ter o mesmo resultado
            assert(resultado_gerenciador == resultado_original);
            
            // Se encontrado, deve apontar para o início do subtexto
            Se (resultado_gerenciador) {
                assert(strncmp(resultado_gerenciador, subtextos[j], strlen(subtextos[j])) == 0);
                assert(strncmp(resultado_original, subtextos[j], strlen(subtextos[j])) == 0);
            }
        }
    }
    
    Retorne 1;
}

// Teste de propriedade: Formatação de texto deve ter comportamento equivalente
Inteiro teste_equivalencia_formate_texto() {
    printf("Testando equivalência de formatação de texto...\n");
    
    Para (Inteiro i = 0; i < 50; i++) {
        Caractere buffer_gerenciador[500];
        Caractere buffer_original[500];
        
        Inteiro numero = rand() % 10000;
        Imutável Caractere *formato = "Número: %d";
        
        // Formatar usando ambas as implementações
        Inteiro resultado_gerenciador = GerenciadorTexto.formate_texto(buffer_gerenciador, formato, numero);
        Inteiro resultado_original = sprintf(buffer_original, formato, numero);
        
        // Ambos devem retornar o mesmo número de caracteres
        assert(resultado_gerenciador == resultado_original);
        
        // O conteúdo formatado deve ser idêntico
        assert(strcmp(buffer_gerenciador, buffer_original) == 0);
    }
    
    Retorne 1;
}

// Teste de propriedade: Operações Unicode devem ter comportamento equivalente
Inteiro teste_equivalencia_unicode() {
    printf("Testando equivalência de operações Unicode...\n");
    
    CaractereUnicode textos_unicode[][50] = {
        L"Hello World",
        L"Teste Unicode",
        L"123456",
        L"",
        L"A"
    };
    
    Inteiro num_textos = 5;
    
    Para (Inteiro i = 0; i < num_textos; i++) {
        // Teste de tamanho Unicode
        TamanhoTexto tamanho_gerenciador = GerenciadorTexto.obtenha_tamanho_unicode(textos_unicode[i]);
        size_t tamanho_original = wcslen(textos_unicode[i]);
        
        assert(tamanho_gerenciador == tamanho_original);
        
        // Teste de cópia Unicode
        CaractereUnicode destino_gerenciador[100];
        CaractereUnicode destino_original[100];
        
        CaractereUnicode *resultado_copia_gerenciador = GerenciadorTexto.copie_texto_unicode(destino_gerenciador, textos_unicode[i]);
        CaractereUnicode *resultado_copia_original = wcscpy(destino_original, textos_unicode[i]);
        
        assert(resultado_copia_gerenciador == destino_gerenciador);
        assert(resultado_copia_original == destino_original);
        assert(wcscmp(destino_gerenciador, destino_original) == 0);
        
        // Teste de comparação Unicode
        Inteiro comp_gerenciador = GerenciadorTexto.compare_texto_unicode(textos_unicode[i], destino_gerenciador);
        Inteiro comp_original = wcscmp(textos_unicode[i], destino_original);
        
        assert((comp_gerenciador == 0) == (comp_original == 0));
    }
    
    Retorne 1;
}

// Teste de propriedade: Tokenização deve ter comportamento equivalente
Inteiro teste_equivalencia_tokenizacao() {
    printf("Testando equivalência de tokenização...\n");
    
    Imutável Caractere *textos_teste[] = {
        "palavra1,palavra2,palavra3",
        "a;b;c;d",
        "token1 token2 token3",
        "um,dois;três quatro"
    };
    
    Imutável Caractere *delimitadores = ",; ";
    Inteiro num_textos = 4;
    
    Para (Inteiro i = 0; i < num_textos; i++) {
        // Criar cópias dos textos para tokenização
        Caractere *texto_gerenciador = (Caractere*)malloc(strlen(textos_teste[i]) + 1);
        Caractere *texto_original = (Caractere*)malloc(strlen(textos_teste[i]) + 1);
        
        assert(texto_gerenciador && texto_original);
        
        strcpy(texto_gerenciador, textos_teste[i]);
        strcpy(texto_original, textos_teste[i]);
        
        // Tokenizar usando ambas as implementações
        Caractere *token_gerenciador = GerenciadorTexto.divida_texto(texto_gerenciador, delimitadores);
        Caractere *token_original = strtok(texto_original, delimitadores);
        
        // Comparar todos os tokens
        Enquanto (token_gerenciador && token_original) {
            assert(strcmp(token_gerenciador, token_original) == 0);
            
            token_gerenciador = GerenciadorTexto.divida_texto(NULL, delimitadores);
            token_original = strtok(NULL, delimitadores);
        }
        
        // Ambos devem terminar ao mesmo tempo
        assert(token_gerenciador == NULL && token_original == NULL);
        
        free(texto_gerenciador);
        free(texto_original);
    }
    
    Retorne 1;
}

Inteiro executar_todos_testes() {
    printf("Executando testes de propriedade para GerenciadorTexto...\n");
    printf("**Valida: Requisitos 7.2**\n");
    printf("**Propriedade 12: Equivalência Comportamental**\n\n");
    
    // Inicializar gerador de números aleatórios
    srand((Inteiro)time(NULL));
    
    assert(teste_equivalencia_obtenha_tamanho());
    printf("✓ Teste equivalência obtenha_tamanho passou\n");
    
    assert(teste_equivalencia_copie_texto());
    printf("✓ Teste equivalência copie_texto passou\n");
    
    assert(teste_equivalencia_concatene_texto());
    printf("✓ Teste equivalência concatene_texto passou\n");
    
    assert(teste_equivalencia_compare_texto());
    printf("✓ Teste equivalência compare_texto passou\n");
    
    assert(teste_equivalencia_busque_caractere());
    printf("✓ Teste equivalência busque_caractere passou\n");
    
    assert(teste_equivalencia_busque_ultimo_caractere());
    printf("✓ Teste equivalência busque_ultimo_caractere passou\n");
    
    assert(teste_equivalencia_busque_texto());
    printf("✓ Teste equivalência busque_texto passou\n");
    
    assert(teste_equivalencia_formate_texto());
    printf("✓ Teste equivalência formate_texto passou\n");
    
    assert(teste_equivalencia_unicode());
    printf("✓ Teste equivalência operações Unicode passou\n");
    
    assert(teste_equivalencia_tokenizacao());
    printf("✓ Teste equivalência tokenização passou\n");
    
    printf("\nTodos os testes de propriedade para GerenciadorTexto passaram com sucesso!\n");
    printf("Propriedade 12 (Equivalência Comportamental) validada com 100 iterações por teste.\n");
    Retorne 1;
}

Inteiro main() {
    Retorne executar_todos_testes() ? 0 : 1;
}