#Inclua "../../../Fonte/Convencional.ctec"
#Inclua <assert.h>
#Inclua <string.h>
#Inclua <stdio.h>
#Inclua <stdlib.h>

// **Valida: Requisitos 7.2**
// **Propriedade 12: Equivalência Comportamental**
// Testa se as funções encapsuladas produzem os mesmos resultados que as originais

Inteiro teste_equivalencia_escreva_caractere() {
    // Redirecionar stdout para capturar saída
    FILE *arquivo_teste = tmpfile();
    Se (!arquivo_teste) Retorne 0;
    
    // Teste com GerenciadorEntradaSaida
    Inteiro resultado_gerenciador = GerenciadorEntradaSaida.escreva_caractere('A');
    
    // Teste com função original
    Inteiro resultado_original = putchar('A');
    
    // Ambos devem retornar o caractere escrito ou EOF em caso de erro
    assert(resultado_gerenciador == resultado_original || 
           (resultado_gerenciador == 'A' && resultado_original == 'A'));
    
    fclose(arquivo_teste);
    Retorne 1;
}

Inteiro teste_equivalencia_abra_arquivo() {
    Imutável Caractere *nome_arquivo = "teste_temp.txt";
    Imutável Caractere *modo = "w";
    
    // Teste com GerenciadorEntradaSaida
    FluxoArquivo *arquivo_gerenciador = GerenciadorEntradaSaida.abra_arquivo(nome_arquivo, modo);
    
    // Teste com função original
    FILE *arquivo_original = fopen(nome_arquivo, modo);
    
    // Ambos devem ter o mesmo comportamento (sucesso ou falha)
    assert((arquivo_gerenciador != NULL) == (arquivo_original != NULL));
    
    Se (arquivo_gerenciador) {
        GerenciadorEntradaSaida.feche_arquivo(arquivo_gerenciador);
        remove(nome_arquivo);
    }
    Se (arquivo_original) {
        fclose(arquivo_original);
        remove(nome_arquivo);
    }
    
    Retorne 1;
}

Inteiro teste_equivalencia_escreva_arquivo() {
    Imutável Caractere *dados = "Teste de escrita";
    Imutável Caractere *nome_arquivo1 = "teste1.txt";
    Imutável Caractere *nome_arquivo2 = "teste2.txt";
    
    // Teste com GerenciadorEntradaSaida
    FluxoArquivo *arquivo1 = GerenciadorEntradaSaida.abra_arquivo(nome_arquivo1, "w");
    assert(arquivo1 != NULL);
    
    TamanhoMemoria resultado_gerenciador = GerenciadorEntradaSaida.escreva_arquivo(
        dados, sizeof(Caractere), strlen(dados), arquivo1);
    GerenciadorEntradaSaida.feche_arquivo(arquivo1);
    
    // Teste com função original
    FILE *arquivo2 = fopen(nome_arquivo2, "w");
    assert(arquivo2 != NULL);
    
    size_t resultado_original = fwrite(dados, sizeof(char), strlen(dados), arquivo2);
    fclose(arquivo2);
    
    // Ambos devem escrever a mesma quantidade de elementos
    assert(resultado_gerenciador == resultado_original);
    
    // Limpeza
    remove(nome_arquivo1);
    remove(nome_arquivo2);
    
    Retorne 1;
}

Inteiro teste_equivalencia_leia_arquivo() {
    Imutável Caractere *dados = "Dados para leitura";
    Imutável Caractere *nome_arquivo = "teste_leitura.txt";
    
    // Criar arquivo de teste
    FILE *arquivo_criacao = fopen(nome_arquivo, "w");
    assert(arquivo_criacao != NULL);
    fwrite(dados, sizeof(char), strlen(dados), arquivo_criacao);
    fclose(arquivo_criacao);
    
    // Buffer para GerenciadorEntradaSaida
    Caractere buffer_gerenciador[100];
    memset(buffer_gerenciador, 0, sizeof(buffer_gerenciador));
    
    // Buffer para função original
    char buffer_original[100];
    memset(buffer_original, 0, sizeof(buffer_original));
    
    // Teste com GerenciadorEntradaSaida
    FluxoArquivo *arquivo1 = GerenciadorEntradaSaida.abra_arquivo(nome_arquivo, "r");
    assert(arquivo1 != NULL);
    
    TamanhoMemoria lido_gerenciador = GerenciadorEntradaSaida.leia_arquivo(
        buffer_gerenciador, sizeof(Caractere), strlen(dados), arquivo1);
    GerenciadorEntradaSaida.feche_arquivo(arquivo1);
    
    // Teste com função original
    FILE *arquivo2 = fopen(nome_arquivo, "r");
    assert(arquivo2 != NULL);
    
    size_t lido_original = fread(buffer_original, sizeof(char), strlen(dados), arquivo2);
    fclose(arquivo2);
    
    // Ambos devem ler a mesma quantidade e o mesmo conteúdo
    assert(lido_gerenciador == lido_original);
    assert(strcmp(buffer_gerenciador, buffer_original) == 0);
    
    // Limpeza
    remove(nome_arquivo);
    
    Retorne 1;
}

Inteiro teste_equivalencia_posicionamento() {
    Imutável Caractere *dados = "0123456789";
    Imutável Caractere *nome_arquivo1 = "teste_pos1.txt";
    Imutável Caractere *nome_arquivo2 = "teste_pos2.txt";
    
    // Criar arquivos de teste
    FILE *arquivo_criacao1 = fopen(nome_arquivo1, "w");
    FILE *arquivo_criacao2 = fopen(nome_arquivo2, "w");
    assert(arquivo_criacao1 != NULL && arquivo_criacao2 != NULL);
    
    fwrite(dados, sizeof(char), strlen(dados), arquivo_criacao1);
    fwrite(dados, sizeof(char), strlen(dados), arquivo_criacao2);
    fclose(arquivo_criacao1);
    fclose(arquivo_criacao2);
    
    // Teste com GerenciadorEntradaSaida
    FluxoArquivo *arquivo1 = GerenciadorEntradaSaida.abra_arquivo(nome_arquivo1, "r");
    assert(arquivo1 != NULL);
    
    // Teste com função original
    FILE *arquivo2 = fopen(nome_arquivo2, "r");
    assert(arquivo2 != NULL);
    
    // Posicionar no meio do arquivo
    Inteiro pos_gerenciador = GerenciadorEntradaSaida.posicione_arquivo(arquivo1, 5, BUSQUE_INICIO);
    int pos_original = fseek(arquivo2, 5, SEEK_SET);
    
    // Ambos devem ter o mesmo resultado
    assert(pos_gerenciador == pos_original);
    
    // Verificar posição atual
    Longo posicao_gerenciador = GerenciadorEntradaSaida.obtenha_posicao(arquivo1);
    long posicao_original = ftell(arquivo2);
    
    assert(posicao_gerenciador == posicao_original);
    
    GerenciadorEntradaSaida.feche_arquivo(arquivo1);
    fclose(arquivo2);
    
    // Limpeza
    remove(nome_arquivo1);
    remove(nome_arquivo2);
    
    Retorne 1;
}

Inteiro teste_equivalencia_fim_erro_arquivo() {
    Imutável Caractere *nome_arquivo = "teste_fim_erro.txt";
    
    // Criar arquivo pequeno
    FILE *arquivo_criacao = fopen(nome_arquivo, "w");
    assert(arquivo_criacao != NULL);
    fwrite("AB", sizeof(char), 2, arquivo_criacao);
    fclose(arquivo_criacao);
    
    // Teste com GerenciadorEntradaSaida
    FluxoArquivo *arquivo1 = GerenciadorEntradaSaida.abra_arquivo(nome_arquivo, "r");
    assert(arquivo1 != NULL);
    
    // Teste com função original
    FILE *arquivo2 = fopen(nome_arquivo, "r");
    assert(arquivo2 != NULL);
    
    // Ler até o fim
    Caractere buffer1[10], buffer2[10];
    GerenciadorEntradaSaida.leia_arquivo(buffer1, 1, 5, arquivo1); // Tentar ler mais que disponível
    fread(buffer2, 1, 5, arquivo2);
    
    // Verificar fim de arquivo
    Inteiro fim_gerenciador = GerenciadorEntradaSaida.fim_arquivo(arquivo1);
    int fim_original = feof(arquivo2);
    
    assert((fim_gerenciador != 0) == (fim_original != 0));
    
    GerenciadorEntradaSaida.feche_arquivo(arquivo1);
    fclose(arquivo2);
    
    // Limpeza
    remove(nome_arquivo);
    
    Retorne 1;
}

Inteiro executar_todos_testes() {
    printf("Executando testes de propriedade para GerenciadorEntradaSaida...\n");
    
    assert(teste_equivalencia_escreva_caractere());
    printf("✓ Teste equivalência escreva_caractere passou\n");
    
    assert(teste_equivalencia_abra_arquivo());
    printf("✓ Teste equivalência abra_arquivo passou\n");
    
    assert(teste_equivalencia_escreva_arquivo());
    printf("✓ Teste equivalência escreva_arquivo passou\n");
    
    assert(teste_equivalencia_leia_arquivo());
    printf("✓ Teste equivalência leia_arquivo passou\n");
    
    assert(teste_equivalencia_posicionamento());
    printf("✓ Teste equivalência posicionamento passou\n");
    
    assert(teste_equivalencia_fim_erro_arquivo());
    printf("✓ Teste equivalência fim/erro arquivo passou\n");
    
    printf("Todos os testes de propriedade passaram com sucesso!\n");
    Retorne 1;
}

Inteiro main() {
    Retorne executar_todos_testes() ? 0 : 1;
}