#Inclua "../../../Fonte/Convencional.ctec"
#Inclua <assert.h>
#Inclua <string.h>
#Inclua <stdio.h>
#Inclua <stdlib.h>
#Inclua <time.h>

// **Valida: Requisitos 7.2**
// **Propriedade 12: Equivalência Comportamental**
// Testa se as funções de memória encapsuladas produzem os mesmos resultados que as originais

// Gerador de dados aleatórios para testes de propriedade
Inteiro gere_tamanho_aleatorio(Inteiro min, Inteiro max) {
    Retorne min + (rand() % (max - min + 1));
}

Inteiro gere_valor_aleatorio() {
    Retorne rand() % 256;
}

// Teste de propriedade: Alocação básica deve ter comportamento equivalente
Inteiro teste_equivalencia_alocacao_basica() {
    printf("Testando equivalência de alocação básica...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoMemoria tamanho = gere_tamanho_aleatorio(1, 8192);
        
        // Teste com GerenciadorMemoria
        PonteiroMemoria ptr_gerenciador = GerenciadorMemoria.aloque(tamanho);
        
        // Teste com função original
        void *ptr_original = malloc(tamanho);
        
        // Ambos devem ter o mesmo comportamento (sucesso ou falha)
        assert((ptr_gerenciador != NULL) == (ptr_original != NULL));
        
        Se (ptr_gerenciador && ptr_original) {
            // Se ambos alocaram, devem permitir escrita
            memset(ptr_gerenciador, 0xAA, tamanho);
            memset(ptr_original, 0xAA, tamanho);
            
            // Verificar que a escrita foi bem-sucedida
            unsigned char *bytes_gerenciador = (unsigned char*)ptr_gerenciador;
            unsigned char *bytes_original = (unsigned char*)ptr_original;
            
            Para (TamanhoMemoria j = 0; j < tamanho; j++) {
                assert(bytes_gerenciador[j] == 0xAA);
                assert(bytes_original[j] == 0xAA);
            }
        }
        
        // Limpeza
        Se (ptr_gerenciador) GerenciadorMemoria.libere(ptr_gerenciador);
        Se (ptr_original) free(ptr_original);
    }
    
    Retorne 1;
}

// Teste de propriedade: Alocação zerada deve ter comportamento equivalente
Inteiro teste_equivalencia_alocacao_zerada() {
    printf("Testando equivalência de alocação zerada...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoMemoria num_elementos = gere_tamanho_aleatorio(1, 1000);
        TamanhoMemoria tamanho_elemento = gere_tamanho_aleatorio(1, 64);
        
        // Teste com GerenciadorMemoria
        PonteiroMemoria ptr_gerenciador = GerenciadorMemoria.aloque_zerado(num_elementos, tamanho_elemento);
        
        // Teste com função original
        void *ptr_original = calloc(num_elementos, tamanho_elemento);
        
        // Ambos devem ter o mesmo comportamento
        assert((ptr_gerenciador != NULL) == (ptr_original != NULL));
        
        Se (ptr_gerenciador && ptr_original) {
            TamanhoMemoria tamanho_total = num_elementos * tamanho_elemento;
            unsigned char *bytes_gerenciador = (unsigned char*)ptr_gerenciador;
            unsigned char *bytes_original = (unsigned char*)ptr_original;
            
            // Ambos devem estar zerados
            Para (TamanhoMemoria j = 0; j < tamanho_total; j++) {
                assert(bytes_gerenciador[j] == 0);
                assert(bytes_original[j] == 0);
            }
        }
        
        // Limpeza
        Se (ptr_gerenciador) GerenciadorMemoria.libere(ptr_gerenciador);
        Se (ptr_original) free(ptr_original);
    }
    
    Retorne 1;
}

// Teste de propriedade: Realocação deve ter comportamento equivalente
Inteiro teste_equivalencia_realocacao() {
    printf("Testando equivalência de realocação...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoMemoria tamanho_inicial = gere_tamanho_aleatorio(100, 1000);
        TamanhoMemoria novo_tamanho = gere_tamanho_aleatorio(50, 2000);
        
        // Alocação inicial
        PonteiroMemoria ptr_gerenciador = GerenciadorMemoria.aloque(tamanho_inicial);
        void *ptr_original = malloc(tamanho_inicial);
        
        Se (ptr_gerenciador && ptr_original) {
            // Preencher com dados conhecidos
            memset(ptr_gerenciador, 0x55, tamanho_inicial);
            memset(ptr_original, 0x55, tamanho_inicial);
            
            // Realocação
            PonteiroMemoria novo_ptr_gerenciador = GerenciadorMemoria.realoque(ptr_gerenciador, novo_tamanho);
            void *novo_ptr_original = realloc(ptr_original, novo_tamanho);
            
            // Ambos devem ter o mesmo comportamento
            assert((novo_ptr_gerenciador != NULL) == (novo_ptr_original != NULL));
            
            Se (novo_ptr_gerenciador && novo_ptr_original) {
                // Verificar que os dados originais foram preservados
                TamanhoMemoria tamanho_preservado = (tamanho_inicial < novo_tamanho) ? tamanho_inicial : novo_tamanho;
                unsigned char *bytes_gerenciador = (unsigned char*)novo_ptr_gerenciador;
                unsigned char *bytes_original = (unsigned char*)novo_ptr_original;
                
                Para (TamanhoMemoria j = 0; j < tamanho_preservado; j++) {
                    assert(bytes_gerenciador[j] == 0x55);
                    assert(bytes_original[j] == 0x55);
                }
                
                // Limpeza
                GerenciadorMemoria.libere(novo_ptr_gerenciador);
                free(novo_ptr_original);
            }
        } Senão {
            // Limpeza em caso de falha na alocação inicial
            Se (ptr_gerenciador) GerenciadorMemoria.libere(ptr_gerenciador);
            Se (ptr_original) free(ptr_original);
        }
    }
    
    Retorne 1;
}

// Teste de propriedade: Cópia de memória deve ter comportamento equivalente
Inteiro teste_equivalencia_copia_memoria() {
    printf("Testando equivalência de cópia de memória...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoMemoria tamanho = gere_tamanho_aleatorio(1, 1024);
        
        // Alocar buffers de origem e destino
        unsigned char *origem = (unsigned char*)malloc(tamanho);
        unsigned char *destino_gerenciador = (unsigned char*)malloc(tamanho);
        unsigned char *destino_original = (unsigned char*)malloc(tamanho);
        
        assert(origem && destino_gerenciador && destino_original);
        
        // Preencher origem com dados aleatórios
        Para (TamanhoMemoria j = 0; j < tamanho; j++) {
            origem[j] = gere_valor_aleatorio();
        }
        
        // Inicializar destinos com valores diferentes
        memset(destino_gerenciador, 0xFF, tamanho);
        memset(destino_original, 0xFF, tamanho);
        
        // Copiar usando ambas as implementações
        PonteiroMemoria resultado_gerenciador = GerenciadorMemoria.copie(destino_gerenciador, origem, tamanho);
        void *resultado_original = memcpy(destino_original, origem, tamanho);
        
        // Ambos devem retornar o ponteiro de destino
        assert(resultado_gerenciador == destino_gerenciador);
        assert(resultado_original == destino_original);
        
        // O conteúdo copiado deve ser idêntico
        assert(memcmp(destino_gerenciador, destino_original, tamanho) == 0);
        assert(memcmp(destino_gerenciador, origem, tamanho) == 0);
        
        // Limpeza
        free(origem);
        free(destino_gerenciador);
        free(destino_original);
    }
    
    Retorne 1;
}

// Teste de propriedade: Movimentação de memória deve ter comportamento equivalente
Inteiro teste_equivalencia_movimentacao_memoria() {
    printf("Testando equivalência de movimentação de memória...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoMemoria tamanho_buffer = gere_tamanho_aleatorio(100, 1000);
        TamanhoMemoria tamanho_copia = gere_tamanho_aleatorio(1, tamanho_buffer / 2);
        TamanhoMemoria offset_origem = gere_tamanho_aleatorio(0, tamanho_buffer - tamanho_copia);
        TamanhoMemoria offset_destino = gere_tamanho_aleatorio(0, tamanho_buffer - tamanho_copia);
        
        // Alocar buffers
        unsigned char *buffer_gerenciador = (unsigned char*)malloc(tamanho_buffer);
        unsigned char *buffer_original = (unsigned char*)malloc(tamanho_buffer);
        
        assert(buffer_gerenciador && buffer_original);
        
        // Preencher com dados aleatórios idênticos
        Para (TamanhoMemoria j = 0; j < tamanho_buffer; j++) {
            unsigned char valor = gere_valor_aleatorio();
            buffer_gerenciador[j] = valor;
            buffer_original[j] = valor;
        }
        
        // Mover usando ambas as implementações
        PonteiroMemoria resultado_gerenciador = GerenciadorMemoria.mova(
            buffer_gerenciador + offset_destino, 
            buffer_gerenciador + offset_origem, 
            tamanho_copia
        );
        
        void *resultado_original = memmove(
            buffer_original + offset_destino, 
            buffer_original + offset_origem, 
            tamanho_copia
        );
        
        // Ambos devem retornar o ponteiro de destino
        assert(resultado_gerenciador == buffer_gerenciador + offset_destino);
        assert(resultado_original == buffer_original + offset_destino);
        
        // O resultado deve ser idêntico
        assert(memcmp(buffer_gerenciador, buffer_original, tamanho_buffer) == 0);
        
        // Limpeza
        free(buffer_gerenciador);
        free(buffer_original);
    }
    
    Retorne 1;
}

// Teste de propriedade: Preenchimento de memória deve ter comportamento equivalente
Inteiro teste_equivalencia_preenchimento_memoria() {
    printf("Testando equivalência de preenchimento de memória...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoMemoria tamanho = gere_tamanho_aleatorio(1, 1024);
        Inteiro valor = gere_valor_aleatorio();
        
        // Alocar buffers
        unsigned char *buffer_gerenciador = (unsigned char*)malloc(tamanho);
        unsigned char *buffer_original = (unsigned char*)malloc(tamanho);
        
        assert(buffer_gerenciador && buffer_original);
        
        // Preencher usando ambas as implementações
        PonteiroMemoria resultado_gerenciador = GerenciadorMemoria.preencha(buffer_gerenciador, valor, tamanho);
        void *resultado_original = memset(buffer_original, valor, tamanho);
        
        // Ambos devem retornar o ponteiro do buffer
        assert(resultado_gerenciador == buffer_gerenciador);
        assert(resultado_original == buffer_original);
        
        // O conteúdo deve ser idêntico
        assert(memcmp(buffer_gerenciador, buffer_original, tamanho) == 0);
        
        // Verificar que todos os bytes têm o valor correto
        Para (TamanhoMemoria j = 0; j < tamanho; j++) {
            assert(buffer_gerenciador[j] == (unsigned char)valor);
            assert(buffer_original[j] == (unsigned char)valor);
        }
        
        // Limpeza
        free(buffer_gerenciador);
        free(buffer_original);
    }
    
    Retorne 1;
}

// Teste de propriedade: Comparação de memória deve ter comportamento equivalente
Inteiro teste_equivalencia_comparacao_memoria() {
    printf("Testando equivalência de comparação de memória...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoMemoria tamanho = gere_tamanho_aleatorio(1, 1024);
        
        // Alocar buffers
        unsigned char *buffer1 = (unsigned char*)malloc(tamanho);
        unsigned char *buffer2 = (unsigned char*)malloc(tamanho);
        
        assert(buffer1 && buffer2);
        
        // Preencher com dados aleatórios
        Para (TamanhoMemoria j = 0; j < tamanho; j++) {
            buffer1[j] = gere_valor_aleatorio();
            buffer2[j] = gere_valor_aleatorio();
        }
        
        // Comparar usando ambas as implementações
        Inteiro resultado_gerenciador = GerenciadorMemoria.compare(buffer1, buffer2, tamanho);
        int resultado_original = memcmp(buffer1, buffer2, tamanho);
        
        // Ambos devem ter o mesmo sinal (positivo, negativo ou zero)
        assert((resultado_gerenciador > 0) == (resultado_original > 0));
        assert((resultado_gerenciador < 0) == (resultado_original < 0));
        assert((resultado_gerenciador == 0) == (resultado_original == 0));
        
        // Teste com buffers idênticos
        memcpy(buffer2, buffer1, tamanho);
        
        resultado_gerenciador = GerenciadorMemoria.compare(buffer1, buffer2, tamanho);
        resultado_original = memcmp(buffer1, buffer2, tamanho);
        
        // Ambos devem retornar zero para buffers idênticos
        assert(resultado_gerenciador == 0);
        assert(resultado_original == 0);
        
        // Limpeza
        free(buffer1);
        free(buffer2);
    }
    
    Retorne 1;
}

// Teste de propriedade: Busca de byte deve ter comportamento equivalente
Inteiro teste_equivalencia_busca_byte() {
    printf("Testando equivalência de busca de byte...\n");
    
    Para (Inteiro i = 0; i < 100; i++) {
        TamanhoMemoria tamanho = gere_tamanho_aleatorio(10, 1000);
        Inteiro valor_busca = gere_valor_aleatorio();
        
        // Alocar buffer
        unsigned char *buffer = (unsigned char*)malloc(tamanho);
        assert(buffer);
        
        // Preencher com dados aleatórios
        Para (TamanhoMemoria j = 0; j < tamanho; j++) {
            buffer[j] = gere_valor_aleatorio();
        }
        
        // Inserir o valor buscado em posição aleatória (50% das vezes)
        Se (rand() % 2) {
            TamanhoMemoria posicao = gere_tamanho_aleatorio(0, tamanho - 1);
            buffer[posicao] = valor_busca;
        }
        
        // Buscar usando ambas as implementações
        PonteiroMemoria resultado_gerenciador = GerenciadorMemoria.busque_byte(buffer, valor_busca, tamanho);
        void *resultado_original = memchr(buffer, valor_busca, tamanho);
        
        // Ambos devem ter o mesmo resultado
        assert(resultado_gerenciador == resultado_original);
        
        // Se encontrado, deve apontar para o valor correto
        Se (resultado_gerenciador) {
            assert(*(unsigned char*)resultado_gerenciador == (unsigned char)valor_busca);
            assert(*(unsigned char*)resultado_original == (unsigned char)valor_busca);
        }
        
        // Limpeza
        free(buffer);
    }
    
    Retorne 1;
}

// Teste de propriedade: Comparação de strings deve ter comportamento equivalente
Inteiro teste_equivalencia_comparacao_string() {
    printf("Testando equivalência de comparação de strings...\n");
    
    Imutável Caractere *strings_teste[] = {
        "abc", "ABC", "123", "teste", "TESTE", "áéíóú", "", "a", "aa", "ab"
    };
    Inteiro num_strings = sizeof(strings_teste) / sizeof(strings_teste[0]);
    
    Para (Inteiro i = 0; i < num_strings; i++) {
        Para (Inteiro j = 0; j < num_strings; j++) {
            // Comparar usando ambas as implementações
            Inteiro resultado_gerenciador = GerenciadorMemoria.compare_string(strings_teste[i], strings_teste[j]);
            int resultado_original = strcmp(strings_teste[i], strings_teste[j]);
            
            // Ambos devem ter o mesmo sinal
            assert((resultado_gerenciador > 0) == (resultado_original > 0));
            assert((resultado_gerenciador < 0) == (resultado_original < 0));
            assert((resultado_gerenciador == 0) == (resultado_original == 0));
        }
    }
    
    Retorne 1;
}

// Teste de propriedade: Cópia de strings deve ter comportamento equivalente
Inteiro teste_equivalencia_copia_string() {
    printf("Testando equivalência de cópia de strings...\n");
    
    Imutável Caractere *strings_teste[] = {
        "Hello World", "Teste", "123456", "áéíóú", "", "a"
    };
    Inteiro num_strings = sizeof(strings_teste) / sizeof(strings_teste[0]);
    
    Para (Inteiro i = 0; i < num_strings; i++) {
        TamanhoMemoria tamanho_necessario = strlen(strings_teste[i]) + 1;
        
        // Alocar buffers de destino
        Caractere *destino_gerenciador = (Caractere*)malloc(tamanho_necessario);
        char *destino_original = (char*)malloc(tamanho_necessario);
        
        assert(destino_gerenciador && destino_original);
        
        // Copiar usando ambas as implementações
        Caractere *resultado_gerenciador = GerenciadorMemoria.copie_string(destino_gerenciador, strings_teste[i]);
        char *resultado_original = strcpy(destino_original, strings_teste[i]);
        
        // Ambos devem retornar o ponteiro de destino
        assert(resultado_gerenciador == destino_gerenciador);
        assert(resultado_original == destino_original);
        
        // O conteúdo copiado deve ser idêntico
        assert(strcmp(destino_gerenciador, destino_original) == 0);
        assert(strcmp(destino_gerenciador, strings_teste[i]) == 0);
        
        // Limpeza
        free(destino_gerenciador);
        free(destino_original);
    }
    
    Retorne 1;
}

Inteiro executar_todos_testes() {
    printf("Executando testes de propriedade para GerenciadorMemória...\n");
    printf("**Valida: Requisitos 7.2**\n");
    printf("**Propriedade 12: Equivalência Comportamental**\n\n");
    
    // Inicializar gerador de números aleatórios
    srand((unsigned int)time(NULL));
    
    assert(teste_equivalencia_alocacao_basica());
    printf("✓ Teste equivalência alocação básica passou\n");
    
    assert(teste_equivalencia_alocacao_zerada());
    printf("✓ Teste equivalência alocação zerada passou\n");
    
    assert(teste_equivalencia_realocacao());
    printf("✓ Teste equivalência realocação passou\n");
    
    assert(teste_equivalencia_copia_memoria());
    printf("✓ Teste equivalência cópia de memória passou\n");
    
    assert(teste_equivalencia_movimentacao_memoria());
    printf("✓ Teste equivalência movimentação de memória passou\n");
    
    assert(teste_equivalencia_preenchimento_memoria());
    printf("✓ Teste equivalência preenchimento de memória passou\n");
    
    assert(teste_equivalencia_comparacao_memoria());
    printf("✓ Teste equivalência comparação de memória passou\n");
    
    assert(teste_equivalencia_busca_byte());
    printf("✓ Teste equivalência busca de byte passou\n");
    
    assert(teste_equivalencia_comparacao_string());
    printf("✓ Teste equivalência comparação de string passou\n");
    
    assert(teste_equivalencia_copia_string());
    printf("✓ Teste equivalência cópia de string passou\n");
    
    printf("\nTodos os testes de propriedade para GerenciadorMemória passaram com sucesso!\n");
    printf("Propriedade 12 (Equivalência Comportamental) validada com 100 iterações por teste.\n");
    Retorne 1;
}

Inteiro main() {
    Retorne executar_todos_testes() ? 0 : 1;
}